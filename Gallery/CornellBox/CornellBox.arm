#import "SnailShell.arm"
#ifndef SAMPLES
#define SAMPLES 400
#endif


//#define MODE arpathtracermode_light_sampling
//#define MODE arpathtracermode_mis




ArObj whiteReflectance(ART_GV * art_gv) {
    return
            CONST_COLOUR_RSSPECTRUM(400 NANOMETER, 4 NANOMETER, 1.0,
            0.343, 0.445, 0.551, 0.624, 0.665, 0.687, 0.708, 0.723, 0.715,
            0.710, 0.745, 0.758, 0.739, 0.767, 0.777, 0.765, 0.751, 0.745,
            0.748, 0.729, 0.745, 0.757, 0.753, 0.750, 0.746, 0.747, 0.735,
            0.732, 0.739, 0.734, 0.725, 0.721, 0.733, 0.725, 0.732, 0.743,
            0.744, 0.748, 0.728, 0.716, 0.733, 0.726, 0.713, 0.740, 0.754,
            0.764, 0.752, 0.736, 0.734, 0.741, 0.740, 0.732, 0.745, 0.755,
            0.751, 0.744, 0.731, 0.733, 0.744, 0.731, 0.712, 0.708, 0.729,
            0.730, 0.727, 0.707, 0.703, 0.729, 0.750, 0.760, 0.751, 0.739,
            0.724, 0.730, 0.740, 0.737, RSS_END
    );
}

ArObj greenReflectance(ART_GV * art_gv) {
    return
            CONST_COLOUR_RSSPECTRUM(400 NANOMETER, 4 NANOMETER, 1.0,
            0.092, 0.096, 0.098, 0.097, 0.098, 0.095, 0.095, 0.097, 0.095,
            0.094, 0.097, 0.098, 0.096, 0.101, 0.103, 0.104, 0.107, 0.109,
            0.112, 0.115, 0.125, 0.140, 0.160, 0.187, 0.229, 0.285, 0.343,
            0.390, 0.435, 0.464, 0.472, 0.476, 0.481, 0.462, 0.447, 0.441,
            0.426, 0.406, 0.373, 0.347, 0.337, 0.314, 0.285, 0.277, 0.266,
            0.250, 0.230, 0.207, 0.186, 0.171, 0.160, 0.148, 0.141, 0.136,
            0.130, 0.126, 0.123, 0.121, 0.122, 0.119, 0.114, 0.115, 0.117,
            0.117, 0.118, 0.120, 0.122, 0.128, 0.132, 0.139, 0.144, 0.146,
            0.150, 0.152, 0.157, 0.159, RSS_END
    );
}

ArObj redReflectance(ART_GV * art_gv) {
    return
            CONST_COLOUR_RSSPECTRUM(400 NANOMETER, 4 NANOMETER, 1.0,
            0.040, 0.046, 0.048, 0.053, 0.049, 0.050, 0.053, 0.055, 0.057,
            0.056, 0.059, 0.057, 0.061, 0.061, 0.060, 0.062, 0.062, 0.062,
            0.061, 0.062, 0.060, 0.059, 0.057, 0.058, 0.058, 0.058, 0.056,
            0.055, 0.056, 0.059, 0.057, 0.055, 0.059, 0.059, 0.058, 0.059,
            0.061, 0.061, 0.063, 0.063, 0.067, 0.068, 0.072, 0.080, 0.090,
            0.099, 0.124, 0.154, 0.192, 0.255, 0.287, 0.349, 0.402, 0.443,
            0.487, 0.513, 0.558, 0.584, 0.620, 0.606, 0.609, 0.651, 0.612,
            0.610, 0.650, 0.638, 0.627, 0.620, 0.630, 0.628, 0.642, 0.639,
            0.657, 0.639, 0.635, 0.64, RSS_END
    );
}

ArObj lightSpectrum(ART_GV * art_gv)
{
    return
#ifdef FL11
        CIE_ILLUMINANT_FL12;
#endif

//   The fall-thorugh default, if no lightsource #define is specified,
//   is the original measured light source spectrum of the Cornell box.

#ifdef D65
        CIE_ILLUMINANT_D65;
#else
            CONST_COLOUR_RSSPECTRUM(400 NANOMETER, 100 NANOMETER, 1.0,
            0.0, 8.0, 15.6, 18.4,
            RSS_END
    );
#endif
}

ArObj createShortBlock(ART_GV * art_gv) {
    Pnt3D * blockPoints = ALLOC_ARRAY( Pnt3D, 9);

    blockPoints[0] = PNT3D(130.0, 165.0,  65.0); // top    right front
    blockPoints[1] = PNT3D( 82.0, 165.0, 225.0); // top    right rear
    blockPoints[2] = PNT3D(290.0, 165.0, 114.0); // top    left  front
    blockPoints[3] = PNT3D(240.0, 165.0, 272.0); // top    left  rear
    blockPoints[4] = PNT3D(130.0,   0.0,  65.0); // bottom right front
    blockPoints[5] = PNT3D( 82.0,   0.0, 225.0); // bottom right rear
    blockPoints[6] = PNT3D(290.0,   0.0, 114.0); // bottom left  front
    blockPoints[7] = PNT3D(240.0,   0.0, 272.0); // bottom left  rear


    blockPoints[8] = PNT3D_HUGE;

    ArObj vertices =
            arnvertexset(
                    art_gv,
                    blockPoints,
                    NULL,
                    NULL,
                    NULL,
                    NULL
            );

    ArObj block =
            UNION(
                    QUADRANGLE( 0, 1, 3, 2 ),
                    QUADRANGLE( 2, 3, 7, 6 ),
                    QUADRANGLE( 6, 4, 5, 7 ),
                    QUADRANGLE( 7, 3, 1, 5 ),
                    QUADRANGLE( 5, 1, 0, 4 ),
                    QUADRANGLE( 4, 0, 2, 6 ),
                    UNION_END
            );

    ArObj blockMaterial = LAMBERT_REFLECTOR(whiteReflectance(art_gv));

    return
    [ block apply
    : vertices
    : blockMaterial
    ];
}
#define SPHERECOLOUR        MUNSELL_025YR_06_06

ArNode * createGroovedSphere(
        ART_GV  * art_gv,
        double    angle,
        double    secondaryRadius
)
{
    double  deltaAngle = atan( secondaryRadius );
    double  angleA = angle - deltaAngle;
    double  angleB = angle + deltaAngle;

    id mainTorus =
    [ TORUS( ( 1.0 / cos(angle) ) * secondaryRadius ) apply
    : USCALE( cos(angle) )
    : TRANSLATION( 0.0, 0.0, sin(angle) )
    ];

    double  torusFactorA =
            ( 1.0 / ( ( 1.0 - secondaryRadius ) * cos(angleA) ) ) * secondaryRadius;

    id subTorusA =
    [ TORUS( torusFactorA ) apply
    : USCALE( ( 1.0 - secondaryRadius ) * cos(angleA) )
    : TRANSLATION( 0.0, 0.0, ( 1.0 - secondaryRadius ) * sin(angleA) )
    ];


    double  torusFactorB =
            ( 1.0 / ( ( 1.0 - secondaryRadius ) * cos(angleB) ) ) * secondaryRadius;

    id subTorusB =
    [ TORUS( torusFactorB ) apply
    : USCALE( ( 1.0 - secondaryRadius ) * cos(angleB) )
    : TRANSLATION( 0.0, 0.0, ( 1.0 - secondaryRadius ) * sin(angleB) )
    ];

    id grooveObj =  [ mainTorus sub : [ subTorusA or : subTorusB ] ];
    id groovePair = [ grooveObj or : [ grooveObj apply : ROT_X( 180 DEGREES )]];

    id  allGrooves =
                UNION(
                        groovePair,
    [ groovePair apply: ROT_X( 90 DEGREES ) ],
    [ groovePair apply: ROT_Y( 90 DEGREES ) ],
    UNION_END
    );

    return [ SPHERE sub: allGrooves ];
}

ArObj createTallBlock(ART_GV * art_gv) {
    Pnt3D * blockPoints = ALLOC_ARRAY( Pnt3D, 9);


    blockPoints[0] = PNT3D(-1.05399, -1.24964, 0.084465 ); // top    right front
    blockPoints[1] = PNT3D(-0.359359, -1.24964, 0.610171 ); // top    right rear
    blockPoints[2] = PNT3D(-0.359359,-0.378502, 0.610171 ); // top    left  front
    blockPoints[3] = PNT3D(-1.05399, -0.378502, 0.084465 ); // top    left  rear
    blockPoints[4] = PNT3D(0.166347, -1.24964, -0.084465 ); // bottom right front
    blockPoints[5] = PNT3D(-0.528289, -1.24964, -0.610171); // bottom right rear
    blockPoints[6] = PNT3D(-0.528289, -0.378502, -0.610171 ); // bottom left  front
    blockPoints[7] = PNT3D(0.166347, -0.378502, -0.084465 ); // bottom left  rear


    blockPoints[8] = PNT3D_HUGE;

    ArObj vertices =
            arnvertexset(
                    art_gv,
                    blockPoints,
                    NULL,
                    NULL,
                    NULL,
                    NULL
            );

    ArObj block =
            UNION(
                    QUADRANGLE( 0, 1, 2, 3 ),
                    QUADRANGLE( 1, 4, 7, 2 ),
                    QUADRANGLE( 2, 7, 6, 3 ),
                    UNION_END
            );

    id synthFluoB =
            CONST_FLUORESCENT_COLOUR(
                    FLUORESCENT_YELLOW_PLAIN,
                    0.025,
    PNT2D( 370 NM, 560 NM ),
    VEC2D(  40 NM,  50 NM )
    );

    id glassRefraction  =
            CONST_COLOUR_RSSPECTRUM(
    380.0 NANOMETER, 300.0 NANOMETER, 1.0,
            1.6,  1.6,  1.6,
            RSS_END
    );

    ArObj pinkGlassVolumeMaterial =
            STANDARD_MATERIAL(
                    glassRefraction,
//            RAINBOW_PINK
//            CONST_ATTENUATION_RGB(0.5, 1000.0, 0.5)
//            CONST_ABSORBANCE_SPECTRUM( RAINBOW_PINK, 100.0 )
//            CONST_REFLECTIVITY_SPECTRUM( ROSCOLUX_MEDIUM_PURPLE, 0.7 )
                    CONST_REFLECTIVITY_SPECTRUM( RAINBOW_PINK_0975, 0.7 )
            );

    ArObj orenOren = OREN_NAYAR_SURFACE_CONST( MUNSELL_025YR_06_06, 10 DEGREES );
    ArObj roughOrenNayar =  TORRANCE_SPARROW_BLINN_SURFACE_CONST( 0.1 DEGREES );

//    ArObj mirror2 =  TORRANCE_SPARROW_BLINN_SURFACE( -0.5 DEGREES );
    ArObj mirror2 =  TORRANCE_SPARROW_BLINN_SURFACE_CONST( 0.1 DEGREES );
    ArObj fluoSurfacc = LAMBERT_REFLECTOR( synthFluoB );
    ArObj blockMaterial = LAMBERT_REFLECTOR(redReflectance(art_gv));
    id  groovedSphere = createGroovedSphere( art_gv, 22 DEGREES, 0.1 );

    id  groovedSphere2 = createGroovedSphere( art_gv, 30 DEGREES, 0.1 );
    id  groovedSphere3 = createGroovedSphere( art_gv, 30 DEGREES, 0.8 );

    id noiseExpr = P3_PERLIN_NOISE(WORLDSPACE_COORDS);
    id shiny = TORRANCE_SPARROW_BLINN_SURFACE_WITH_MATERIAL_CONST(0.05,PLATINUM_MATERIAL);
    id rim = TORRANCE_SPARROW_BLINN_SURFACE_WITH_MATERIAL_CONST(0.18,GOLD_MATERIAL);
    id notsoshiny = TORRANCE_SPARROW_BLINN_SURFACE_WITH_MATERIAL_CONST(0.35,SELENIUM_MATERIAL);
    id othershiny = TORRANCE_SPARROW_BLINN_SURFACE_WITH_MATERIAL_CONST(0.05,PLATINUM_MATERIAL);
//    id surface =
//        MAPPED_SURFACE(
//            noiseExpr,
//            SURFACE_MAP(
//                0.0, shiny,
//                0.25, shiny,
//                0.45, rim,
//                0.5, notsoshiny,
//                0.6, notsoshiny,
//                0.65, rim,
//                0.75, othershiny,
//                1.0, othershiny,
//                MAP_END
//                )
//            );
//
//
//
//    ArObj shell =
//        [ create_Shell(art_gv) apply
////        [ SPHERE apply
//            :   USCALE(0.3)
//            :   ROT_Z(110 DEGREES)
//            :   TRANSLATION(0, 0.24964 ,0.984465)
//            :   surface
////            :   TORRANCE_SPARROW_BLINN_SURFACE_WITH_MATERIAL(noiseExpr,SELENIUM_MATERIAL)
//            ];


    groovedSphere =
            [ groovedSphere apply :

                            fluoSurfacc
                :   USCALE(0.55)
                :   ROT_Y(65 DEGREES)
                :   ROT_Z(245 DEGREES)
                :   TRANSLATION(0.7, -1.24964 + 0.5 , 0.00084465)

              ];

    groovedSphere2 =
    [ groovedSphere2 apply :

                    fluoSurfacc
    :   USCALE(0.55)
    :   ROT_Y(65 DEGREES)
    :   TRANSLATION(-1.05399 + 0.3, 0.24964 ,0.084465)

    ];

    groovedSphere3 =
    [ groovedSphere2 apply :

    mirror2
    :   USCALE(0.55)
    :   ROT_Y(65 DEGREES)
    :   TRANSLATION(-1.05399 + 0.7,-1.24964 + 0.4 , -0.44465)

    ];

    ArObj torus =
    [ TORUS(0.3) apply
    :    mirror2
    :    pinkGlassVolumeMaterial
    ];

    ArObj cone =
    [ CONE apply
    :   mirror2
    :   pinkGlassVolumeMaterial
    ];

    ArObj sphere =
    [ SPHERE apply
    :   mirror2
    ];

    ArObj sphere2 =
    [ SPHERE apply
    :   mirror2
    :   pinkGlassVolumeMaterial
    ];


    sphere =
    [ sphere apply
    :   USCALE(0.44)
    :   ROT_Y(65 DEGREES)
    :   ROT_Z(245 DEGREES)
    :   TRANSLATION(-1.05399 + 0.7,-1.24964 + 0.4 , -1.00084465)
    ];

    ArObj sphere3 =
            [ sphere apply
                    :   ROT_Y(65 DEGREES)
    :   ROT_Z(245 DEGREES)
    :   TRANSLATION(-1.05399 + 2, -2.24964 , -0.5)
    ];


    torus =
    [ torus apply
    :   USCALE(0.44)
                      : ROT_X(0 DEGREES)
    :   TRANSLATION(0, 0.8, 0)
    ];

    cone =
    [ cone apply
    :   USCALE(0.4)
            : ROT_X(90 DEGREES)
    :   TRANSLATION(0, -0.26009002f, 0)
    ];

    sphere2 =
    [ sphere2 apply
    :   USCALE(0.44)
    :   ROT_Y(65 DEGREES)
    :   ROT_Z(245 DEGREES)
    :   TRANSLATION(-0.55, 0.68002f, 0)
    ];

    return UNION(sphere, torus, sphere3, UNION_END);
//    return UNION(shell, UNION_END);
//    return
//    [ block apply
//    : vertices
//    : blockMaterial
//    ];
}

ArObj createLight(ART_GV * art_gv) {
    Pnt3D * blockPoints = ALLOC_ARRAY( Pnt3D, 9);


    blockPoints[0] = PNT3D( -1.27029f, -1.28002f,  -1.30455f ); // left   top    rear
    blockPoints[1] = PNT3D(  1.28975f, -1.28002f,  -1.30455f ); // left   top    front

    blockPoints[2] = PNT3D(  0.25f,  1.26002f,  -0.25f ); // left   bottom rear
    blockPoints[3] = PNT3D( -0.25f,  1.26002f,  -0.25f ); // left   bottom front


    blockPoints[4] = PNT3D( -1.27029f, -1.28002f, 1.25549f ); // right  top    rear
    blockPoints[5] = PNT3D(  1.28975f, -1.28002f, 1.25549f ); // right  top    front

    blockPoints[6] = PNT3D(  0.25f,  1.26002f,  0.25f  ); // right  bottom rear
    blockPoints[7] = PNT3D( -0.25f,  1.26002f,   0.25f ); // right  bottom front

    /////////////////////////////////////
//    blockPoints[0] = PNT3D(    1.28975f, -0.35,  0); // left   top    rear
//    blockPoints[1] = PNT3D(    1.28975f, -0.35,  0.25); // left   top    front
//
//    blockPoints[2] = PNT3D(   1.28975f,  -0.55f, 0.25); // left   bottom rear
//    blockPoints[3] = PNT3D(   1.28975f,  -0.55f, 0); // left   bottom front

    /////
    blockPoints[0] = PNT3D(    -0.15, 1.28002f,    -0.15 ); // left   top    rear
    blockPoints[1] = PNT3D(     0.15,  1.28002f,   -0.15 ); // left   top    front

    blockPoints[2] = PNT3D(     0.15f,  1.28002f,  0.15f ) ; // left   bottom rear
    blockPoints[3] = PNT3D(    -0.15f,  1.28002f, 0.15f ); // left   bottom front




//    blockPoints[0] = PNT3D( -0.69083f, -0.660441f,  -0.156858f ); // left   top    rear
//    blockPoints[1] = PNT3D(  -0.232487f, -0.660441f,  -0.156858f ); // left   top    front
//
//    blockPoints[2] = PNT3D(  -0.232487f,  -1.11878f,  -0.156858f ); // left   bottom rear
//    blockPoints[3] = PNT3D( -0.69083f,  -1.11878f,  -0.156858f ); // left   bottom front
//
//
//    blockPoints[4] = PNT3D( -0.69083f, -0.660441f, -0.231655f ); // right  top    rear
//    blockPoints[5] = PNT3D(  -0.232487f, -0.660441f, -0.231655f ); // right  top    front
//
//    blockPoints[6] = PNT3D(  -0.232487f,  -1.11878f,  -0.231655f  ); // right  bottom rear
//    blockPoints[7] = PNT3D( -0.69083f,  -1.11878f,   -0.231655f ); // right  bottom front




    blockPoints[8] = PNT3D_HUGE;

    ArObj vertices =
            arnvertexset(
                    art_gv,
                    blockPoints,
                    NULL,
                    NULL,
                    NULL,
                    NULL
            );

    ArObj block = QUADRANGLE(0, 1, 2, 3);
//    ArObj block = QUADRANGLE(2,6,7,3);
    ArObj blockMaterial = LAMBERT_EMITTER  (lightSpectrum(art_gv), 1.0 );

    return
    [ block apply
    : vertices
    : blockMaterial
    ];
}

ArObj createBox(ART_GV * art_gv) {
    Pnt3D * boxPoints = ALLOC_ARRAY( Pnt3D, 13);

    boxPoints[0] = PNT3D( -1.27029f, -1.28002f,  -1.30455f ); // left   top    rear
    boxPoints[1] = PNT3D(  1.28975f, -1.28002f,  -1.30455f ); // left   top    front
    boxPoints[2] = PNT3D(  1.28975f,  1.28002f,  -1.30455f ); // left   bottom rear
    boxPoints[3] = PNT3D( -1.27029f,  1.28002f,  -1.30455f ); // left   bottom front

    boxPoints[4] = PNT3D( -1.27029f, -1.28002f, 1.25549f ); // right  top    rear
    boxPoints[5] = PNT3D(  1.28975f, -1.28002f, 1.25549f ); // right  top    front
    boxPoints[6] = PNT3D(  1.28975f,  1.28002f, 1.25549f ); // right  bottom rear
    boxPoints[7] = PNT3D( -1.27029f,  1.28002f, 1.25549f ); // right  bottom front


    boxPoints[8] = PNT3D( -6.27029f, -6.28002f,  6.30455f ); // left   top    rear
    boxPoints[9] = PNT3D(  6.28975f, -6.28002f,  6.30455f ); // left   top    front
    boxPoints[10] = PNT3D(  6.28975f,  6.28002f,  6.30455f ); // left   bottom rear
    boxPoints[11] = PNT3D( -6.27029f,  6.28002f,  6.30455f ); // left   bottom front

    boxPoints[12] = PNT3D_HUGE;
    id synthFluoB =
            CONST_FLUORESCENT_COLOUR(
                    FLUORESCENT_YELLOW_PLAIN,
                    0.025,
    PNT2D( 370 NM, 560 NM ),
    VEC2D(  40 NM,  50 NM )
    );
    ArObj vertices =
            arnvertexset(
                    art_gv,
                    boxPoints,
                    NULL,
                    NULL,
                    NULL,
                    NULL
            );
    ArObj fluoSurfacc = LAMBERT_REFLECTOR( synthFluoB );
    ArObj whiteLambert    = LAMBERT_REFLECTOR(whiteReflectance(art_gv));
    ArObj redLambert      = LAMBERT_REFLECTOR(redReflectance(art_gv));
    ArObj greenLambert    = LAMBERT_REFLECTOR(greenReflectance(art_gv));
    ArObj emitterMaterial = LAMBERT_EMITTER  (lightSpectrum(art_gv), 1.0 );
    ArObj orenOren = OREN_NAYAR_SURFACE_CONST( MUNSELL_025YR_06_06, 10 DEGREES );

    ArObj floorGeometry =
    [ QUADRANGLE(5, 1, 0, 4) apply
    : whiteLambert
    ];

    ArObj ceilingGeometry =
    [ QUADRANGLE(2,6,7,3) apply
    : redLambert
    ];

    ArObj rightWallGeometry =
    [ QUADRANGLE(1, 5, 6, 2) apply
    : redLambert
    ];

    ArObj leftWallGeometry =
    [ QUADRANGLE(0, 3, 7, 4) apply
    : redLambert
    ];

    ArObj backWallGeometry =
    [ QUADRANGLE(0, 1, 2, 3) apply
    : whiteLambert
    ];

//    ArObj frontWall =
//    [ QUADRANGLE(8, 9, 10, 11) apply
//    : orenOren
//    ];

    ArObj lightGeometry =
    [ TRIANGLE(5, 1, 0) apply
    : emitterMaterial
    ];

    ArObj box =
            UNION(
                    floorGeometry,
                    rightWallGeometry,
                    ceilingGeometry,
                    leftWallGeometry,
                    backWallGeometry,
//                    frontWall,
                    //lightGeometry,
                    UNION_END
            );

    return [ box apply: vertices ];
}


ARM_MAIN_FUNCTION(CornellBox)
        {
                ArObj scene_geometry =
        UNION(
        createBox(art_gv),
        // createShortBlock(art_gv),
        createTallBlock(art_gv),
        createLight(art_gv),
        UNION_END
        );

        id camera =
        [ CAMERA
        imageSize: IVEC2D(512, 512)
        ray:       RAY3D(PNT3D(-0.0439815f, 0.222539f, 4.12529f), VEC3D(0.00688625f, -0.0542161f, -0.998505f))
        zoom:      1
        ];

        ArObj actionsquence =
        ACTION_SEQUENCE(
        CREATE_STANDARD_RAYCASTING_ACCELERATION_STRUCTURE,

        [ LIGHTSOURCE_COLLECTOR
        sampler2D:   STANDARD_SAMPLER_2D
        resolution:  5
        type:        arlightsourcetype_area
        ],

        [ STOCHASTIC_BACKWARDS_PIXEL_SAMPLER
        sampleProvider:
        [VCM
        rayCaster:        STANDARD_RAYCASTER
        maximalRecursion: 9
        mode: arvcmmode_vm
        ]
        sampleSplattingKernel: TENT_KERNEL
        samplesPerPixel:       SAMPLES
        randomValueGeneration: RANDOM_SEQUENCE
        ],

        [ IMAGECONVERSION_RAW_TO_ARTCSP
        removeSource: NO
        ],

        [ IMAGECONVERSION_ARTCSP_TO_EXR
        removeSource:   NO
        ],

        ACTION_SEQUENCE_END
        );

        return
        [ SCENE
        sceneGeometry:  scene_geometry
        camera:         camera
        actionSequence: actionsquence
        ];
        }
